const fs = require('fs');
const path = require('path');
const { promisify } = require('util');

const readFile = promisify(fs.readFile);
const writeFile = promisify(fs.writeFile);
const glob = promisify(require('glob'));
const mkdirp = promisify(require('mkdirp'));


const mdTable = require('markdown-table');


const isModulePath = /^[/.]|node_modules/;


async function resolveDocMetadata(gasket) {
  const { metadata, config } = gasket;
  const { root: appRoot = process.cwd() } = config;

  async function resolveFiles(moduleInfo) {
    const { docs = {} } = moduleInfo;
    let { path: root, name } = moduleInfo;
    const { includes = [] } = docs;
    let { entry, description } = docs;

    if (isModulePath.test(name)) {
      root = appRoot;
      name = path.basename(name);
    } else {
      entry = entry || 'README.md';
    }

    description = description || moduleInfo.description ||
      moduleInfo.package && moduleInfo.package.description;

    const files = (await Promise.all(
      includes.map(async g => await glob(g, { cwd: root }))
    )).reduce((acc, cur) => acc.concat(cur), entry ? [entry] : []);

    // eslint-disable-next-line require-atomic-updates
    moduleInfo.docs = {
      ...docs,
      entry,
      name,
      description,
      root,
      files
    };
  }

  await Promise.all([
    resolveFiles(metadata.app),
    ...metadata.presets.map(async p => resolveFiles(p)),
    ...metadata.plugins.map(async p => resolveFiles(p))
  ]);
}

async function generateDocFiles(gasket) {
  const { metadata, config: gasketConfig } = gasket;
  const { root: appRoot = process.cwd(), docs: config = {} } = gasketConfig;
  const { dir = '.docs' } = config;

  const transforms = [(content) => {
    return content.replace('https://github.com/godaddy/gasket/tree/master/', '/');
  }];

  async function generateFiles(moduleInfo, subDir) {
    const { docs = {} } = moduleInfo;
    const { root, files, name } = docs;
    const tgtRoot = path.join(appRoot, dir, subDir, name);

    await Promise.all(files.map(async file => {
      const source = path.join(root, file);
      const target = path.join(tgtRoot, file);
      let content = await readFile(source, 'utf8');
      content = transforms.reduce((acc, tx) => tx(acc, { source, target, moduleInfo, gasket }), content);
      await mkdirp(path.dirname(target));
      return await writeFile(target, content);
    }));
  }

  await Promise.all([
    // moveDocs(metadata.app),
    ...metadata.presets.map(async p => generateFiles(p, 'presets')),
    ...metadata.plugins.map(async p => generateFiles(p, 'plugins'))
  ]);
}

async function generateIndex(gasket) {
  const { metadata, config: gasketConfig } = gasket;
  const { root: appRoot = process.cwd(), docs: config = {} } = gasketConfig;
  const { dir = '.docs', entry: topEntry = 'README.md' } = config;
  const tgtRoot = path.join(appRoot, dir);
  const target = path.join(tgtRoot, topEntry);

  const links = [];

  let content = '<!-- generated by `gasket docs` -->';
  const line = (text = '') => { content += '\n' + text; };
  const table = elems => { line(mdTable(elems));};

  line();
  line(`# ${metadata.app.docs.name}`);
  line();
  line(metadata.app.docs.description || '');
  line();

  const modulesSection = (sectionTitle, sectionDesc, subdir, infos) => {
    line(`## ${sectionTitle}`);
    line();
    line(sectionDesc);
    line();
    table([
      ['Name', 'Version', 'Description'],
      ...infos.map(info => {
        const { docs, version } = info;
        const { entry, name, description, files } = docs;
        if (entry) {
          const entryPath = path.join('.', subdir, name, files[0]);
          links.push([name, entryPath]);
        }
        return [entry ? `[${name}]` : name, version, description];
      })
    ]);
    line();
  };

  modulesSection('Plugins', 'All configured plugins', 'plugins', metadata.plugins);
  modulesSection('Presets', 'All configured presets', 'presets', metadata.presets);

  line('<!-- LINKS -->');
  line();
  links.forEach(([name, link]) => {
    line(`[${name}]:${link}`);
  });

  return await writeFile(target, content);
}

module.exports = {
  name: 'docs',
  hooks: {
    getCommands: function getCommandsHook(gasket, { BaseCommand }) {
      class DocsCommand extends BaseCommand {
        async runHooks() {
          const { metadata } = this.gasket;

          // await this.gasket.execApply('docs', async ({ name }, handler) => {
          //   const pluginInfo = metadata.plugins.find(p => p.module.name === name || p.name === name);
          //   const docs = await handler();
          // });

          // assign docs details to metadata
          await resolveDocMetadata(gasket);
          // generate the markdown files
          await generateDocFiles(gasket);
          // generate the index file
          await generateIndex(gasket);



          console.log(metadata.plugins.map(p => ({ name: p.name, docs: p.docs })));
        }
      }

      DocsCommand.id = 'docs';
      DocsCommand.description = 'Generate docs for the app';

      return DocsCommand;
    }
  }
};
